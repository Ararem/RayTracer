using RayTracer.Core.Debugging;
using RayTracer.Core.Environment;
using RayTracer.Core.Scenes;
using SixLabors.ImageSharp;
using SixLabors.ImageSharp.PixelFormats;
using System.Numerics;
using System.Runtime.CompilerServices;
using static RayTracer.Core.Graphics.GraphicsHelper;

namespace RayTracer.Core.Graphics;

/// <summary>
///  Class for rendering a <see cref="scene"/>, using it's <see cref="Scenes.Scene.Camera"/>.
/// </summary>
/// <remarks>
///  Uses the rays generated by the <see cref="camera"/>, and objects in the <see cref="scene"/> to create the output image
/// </remarks>
public sealed class AsyncRenderJob
{
	/// <summary>
	///  Creates an async render job for a <paramref name="scene"/>, with configurable <paramref name="renderOptions"/>
	/// </summary>
	/// <param name="scene">The scene containing the objects and camera for the render</param>
	/// <param name="renderOptions">
	///  Record containing options that affect how the resulting image is produced, such as resolution, multisample count or debug
	///  visualisations
	/// </param>
	public AsyncRenderJob(Scene scene, RenderOptions renderOptions)
	{
		Buffer                       = new Image<Rgb24>(renderOptions.Width, renderOptions.Height);
		this.renderOptions           = renderOptions;
		rawBuffer                    = new Colour[renderOptions.Width * renderOptions.Height];
		sampleCounts                 = new int[renderOptions.Width * renderOptions.Height];
		taskCompletionSource         = new TaskCompletionSource<Image<Rgb24>>(this);
		(_, camera, objects, skybox) = scene;
		Task.Run(RenderInternal);
	}

	private void RenderInternal()
	{
		for (int s = 0; s < renderOptions.Samples; s++)
			for (int x = 0; x < renderOptions.Width; x++)
				for (int y = 0; y < renderOptions.Height; y++)
					RenderAndUpdatePixel(x, y);

		//Notify that the render is complete
		taskCompletionSource.SetResult(Buffer);
	}

	private void RenderAndUpdatePixel(int x, int y)
	{
		//Get the view ray from the camera
		//We have to flip the y- value because the camera expects y=0 to be the bottom
		//But the image expects it to be at the top
		Ray r = camera.GetRay((float)x / renderOptions.Width, (float)(renderOptions.Height - y - 1) / renderOptions.Height);

		//Check camera view ray magnitude is 1
		GraphicsValidator.CheckRayDirectionMagnitude(ref r, camera);

		//Sky colour
		Colour col = skybox.GetSkyColour(r);

		//Loop over the objects to see if we hit anything
		foreach (SceneObject sceneObject in objects)
		{
			//Account for the offset of the object
			Ray correctedRay = new(r.Origin - sceneObject.Position, r.Direction);
			//TODO: Object rotation
			if (sceneObject.Hittable.TryHit(correctedRay, renderOptions.KMin, renderOptions.KMax) is { } hit)
			{
				GraphicsValidator.CheckNormalMagnitude(ref hit, sceneObject);
				GraphicsValidator.CheckKValueRange(ref hit, renderOptions, sceneObject);

				switch (renderOptions.DebugVisualisation)
				{
					case GraphicsDebugVisualisation.Normals:
					{
						//Convert normal values [-1..1] to [0..1]
						Vector3 n = (hit.Normal + Vector3.One) / 2f;
						col = (Colour)n;
						break;
					}
					case GraphicsDebugVisualisation.FaceDirection:
					{
						//Convert normal values [-1..1] to [0..1]
						col = hit.OutsideFace ? Colour.Green : Colour.Red;
						break;
					}
					//Render the object normally
					case GraphicsDebugVisualisation.Depth:
					{
						//I have several ways for displaying the depth
						//Changing `a` affects how steep the curve is. Higher values cause a faster drop off
						//Have to ensure it's >0 or else all functions return 1
						const float a = .200f;
						// ReSharper disable once JoinDeclarationAndInitializer
						float t;
						float z = hit.K - renderOptions.KMin;

						// t   = z / (RenderOptions.KMax - RenderOptions.KMin); //Inverse lerp k to [0..1]. Doesn't work when KMax is large (especially infinity
						// t   = MathF.Pow(MathF.E, -a * z);                    //Exponential
						// t   = 1f / ((a * z) + 1);                            //Reciprocal X. Get around asymptote by treating KMin as 0, and starting at x=1
						// t   = 1 - (MathF.Atan(a * z) * (2f / MathF.PI));     //Inverse Tan
						t   = MathF.Pow(MathF.E, -(a * z * z)); //Bell Curve
						col = new Colour(t);
						break;
					}
					case GraphicsDebugVisualisation.None:
					default:
						col = MathF.Sin(x / 40f) * MathF.Sin(y / 20f) < 0 ? Colour.Black : Colour.Blue + Colour.Red;
						break;
				}
			}
		}

		//Now we have our pixel, write it to the buffers
		UpdateBuffers(x, y, col);
	}

	private void UpdateBuffers(int x, int y, Colour pixel)
	{
		//Lock to prevent other threads from changing our pixel
		bufferLock.EnterWriteLock();
		int i = Compress2DIndex(x, y, renderOptions.Width, renderOptions.Height);
		sampleCounts[i]++;
		rawBuffer[i] += pixel;
		Buffer[x, y] =  (Rgb24)(rawBuffer[i] / sampleCounts[i]);
		bufferLock.ExitWriteLock();
	}

#region Internal state

	private readonly Camera        camera;
	private readonly SkyBox        skybox;
	private readonly SceneObject[] objects;
	private readonly RenderOptions renderOptions;

	//TODO: Make a better locking system than locking the entire array
	private readonly ReaderWriterLockSlim bufferLock = new();

	/// <summary>
	///  Raw buffer containing denormalized colour values ([0..SampleCount])
	/// </summary>
	private readonly Colour[] rawBuffer;

	/// <summary>
	///  Buffer recording how many samples make up a given pixel, to create averages
	/// </summary>
	private readonly int[] sampleCounts;

	/// <summary>
	///  Image buffer for the output image
	/// </summary>
	public Image<Rgb24> Buffer { get; }

#endregion

#region Task-like awaitable implementation

	/// <summary>
	///  Whether this render job has completed rendering
	/// </summary>
	public bool RenderCompleted => taskCompletionSource.Task.IsCompleted;

	/// <summary>
	///  Internal object used for task-like awaiting
	/// </summary>
	private readonly TaskCompletionSource<Image<Rgb24>> taskCompletionSource;

	/// <summary>
	///  Gets the task awaiter for this instance
	/// </summary>
	public TaskAwaiter<Image<Rgb24>> GetAwaiter() => taskCompletionSource.Task.GetAwaiter();

#endregion
}